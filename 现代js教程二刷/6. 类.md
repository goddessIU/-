1. class
class User {...} 构造实际上做了如下的事儿：

创建一个名为 User 的函数，该函数成为类声明的结果。该函数的代码来自于 constructor 方法（如果我们不编写这种方法，那么它就被假定为空）。
存储类中的方法，例如 User.prototype 中的 sayHi。

```js
class User {
    constructor(name) { this.name = name; }
    sayHi() { alert(this.name); }
}
console.log(typeof User)//function
console.log(User === User.prototype.constructor)
console.log(User.prototype.sayHi)
```


通过 class 创建的函数具有特殊的内部属性标记 [[IsClassConstructor]]: true
类方法不可枚举。 类定义将 "prototype" 中的所有方法的 enumerable 标志设置为 false。


类字段设置在对象上
```js
class User {
  name = "John";
}

let user = new User();
alert(user.name); // John
alert(User.prototype.name); // undefined
```


解决this丢失
```js
class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value);
  }
}

let button = new Button("hello");

setTimeout(button.click, 1000); // undefined
```
这样解决
```js
class Button {
  constructor(value) {
    this.value = value;
  }
  click = () => {
    alert(this.value);
  }
}

let button = new Button("hello");

setTimeout(button.click, 1000); // hello
```