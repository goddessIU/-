# 手写题学习
https://juejin.cn/post/6946022649768181774#heading-17
学的这个

1. 数据类型判断
```js
function judgeType(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()
}
```

2. 继承
```js
// 原型链继承
function Animal() {
    this.colors = [1, 2]
}
Animal.prototype.getColors = function() {
    return this.colors
}

function Dog() {}
Dog.prototype = new Animal()


// 盗用构造函数
function Animal(name) {
    this.name = name
    this.colors = [1, 2]
}

Animal.prototype.getName = function() {
    return this.name
}

function Dog(name, age) {
    Animal.call(this, name)
    this.age = age
}
Dog.prototype = new Animal()

// 组合继承
function Animal(name) {
    this.name = name
    this.colors = [1, 2]
}
Animal.prototype.getName = function() {
    return this.name
}

function Dog(name, age) {
    Animal.call(this, name)
    this.age = age
}
Dog.prototype = new Animal()
Dog.prototype.constructor = Dog

//寄生式组合继承
function object(o) {
    function F() {}
    F.prototype = o
    return F()
}
function inheritPrototype(child, parent) {
    let prototype = object(parent.prototype)
    child.prototype = prototype
    child.prototype.constructor = child
}
//或者zhemexie
function inherit(child, parent) {
    child.prototype = Object.create(parent.prototype)
    child.prototype.constructor = child
}

//类继承
class Animal {
    constructor(name) {
        this.name = name
    }
}

class Dog extends Animal {
    constructor(name, age) {
        super(name)
        this.age = age
    }
}
```

3. 去重
```js
function unique(arr) {
    return arr.filter((item, index, array) => {
        return array.indexOf(item) === index
    })
}

function uniqueES6(arr) {
    return [...new Set(arr)]
}
```

4. 深浅拷贝
```js
function shallowCopy(obj) {
    if (typeof obj !== 'object') return obj

    let res = {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            res[key] = obj[key]
        }
    }
    
    return res
}

function deepClone(obj) {
    if (typeof obj !== 'object') return obj

    let res = Array.isArray(obj) ? [] : {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (typeof obj[key] !== 'object') {
                res[key] = obj[key]
            } else {
                res[key] = deepClone(obj[key])
            }
        }
    }
    return res
}

const isObject = (target) => ((typeof target === 'function' || typeof target == 'object') && target !== null) 
function deepClone2(target, map = new WeakMap()) {
    if (map.get(target)) {
        return target
    }

    let constructor = target.constructor
    if (/^(RegExp|Date)$/i.test(constructor.name)) {
        return new constructor(target)
    }

    if (isObject(target)) {
        map.set(target, true)
        const cloneTarget = Array.isArray(target) ? [] : {}
        for (let key in target) {
            if (target.hasOwnProperty(key)) {
                cloneTarget[key] = deepClone(target[key], map)
            }
        }
        return cloneTarget
    } else {
        return target
    }
}
```

5. 防抖
```js
function debounce(func, wait) {
    let timeout
    return function() {
        let context = this
        let args = arguments
        clearTimeout(timeout)
        timeout = setTimeout(() => {
            func.apply(context, args)
        }, wait)
    }
}


function debounce2(func, wait, immediate) {
    let timeout, result
    let debounced =  function() {
        let context = this
        let args = arguments
        if (immediate) {
            var callNow = !timeout
            timeout = setTimeout(function() {
                timeout = null
            }, wait)
            if (callNow) result = func.apply(context, args)
        } else {
            clearTimeout(timeout)
            timeout = setTimeout(function() {
                func.apply(context, args)
            }, wait)
        }
        return result
    }
    debounced.cancel = function() {
        clearTimeout(timeout)
        timeout = null
    }
    return debounced
}
```

6. 节流
https://github.com/mqyqingfeng/Blog/issues/26
结合这个看
```js
function throttle(func, wait) {
    var context, args
    var previouse = 0

    return function() {
        context = this
        args = arguments
        let now = +new Date()
        if (now - previouse > wait) {
            func.apply(context, args)
            previouse = now
        }
    }
}

function throttle2(func, wait, options) {
    var timeout

    return function() {
        let context = this
        let args = arguments

        if (!timeout) {
            timeout = setTimeout(function() {
                timeout = null
                func.apply(context, args)
            }, wait)
        }
    }
}

function throttle3(func, wait, options) {
    let timeout, context, args, result
    let previous = 0
    if (!options) options = {}

    var later = function() {
        previous = options.leading === false ? 0 : new Date().getTime()
        timeout = null
        func.apply(context, args)
        if (!timeout) context = args = null
    }

    var throttled = function() {
        var now = new Date().getTime()
        if (!previous && options.leading === false) previous = now
        let remaining = wait - (now - previous)
        context = this
        args = arguments
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout)
                timeout = null
            }
            previous = now
            func.apply(context, args)
            if (!timeout) context = args = null
        } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining)
        }
    }
    throttled.cancel = function() {
        clearTimeout(timeout)
        timeout = null
        previous = 0
    }
    return throttled
}
```

7. 实现new
```js

function objectFactory() {
    let obj = new Object()
    const Constructor = [].shift.call(arguments)
    obj.__proto__ = Constructor.prototype
    let res = Constructor.apply(obj, arguments)

    return typeof res === 'object' ? res || obj : obj 
}
```