# 面试总结2
https://www.nowcoder.com/tutorial/96/c885e81dc46b4dcfa579d76d0aa94c96
出处如上

1. DOCTYPE作用

## Vue部分
1. v-model作用
2. Vue3双向绑定
3. Vuex
4. Vue-Router
5. 组件通信
6. keep-alive
keep-alive：keep-alive可以实现组件缓存
常用的两个属性include/exclude，允许组件有条件的进行缓存。
两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。
7. $nextTick 作用与原理
8. v-if v-show
v-show不管条件是真还是假，第一次渲染的时候都会编译出来，也就是标签都会添加到DOM中。之后切换的时候，通过display: none;样式来显示隐藏元素。可以说只是改变css的样式，几乎不会影响什么性能。
在首次渲染的时候，如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始局部编译，动态的向DOM元素里面添加元素。当条件从真变为假的时候，开始局部编译，卸载这些元素，也就是删除。
9.  Vue 列表为什么加 key
主要是为了高效的更新虚拟DOM
10. 用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。

11. 生命周期
 生命周期
https://learnvue.co/2020/12/how-to-use-lifecycle-hooks-in-vue3/#beforecreate-options-api
beforeCreate: beforeCreate does not have access to any of a component’s reactive data and events.

created: we have initialized our data.

setup: replaced beforeCreate and created

mounting hooks handle mounting and rendering the component. 

beforeMount:   before the component DOM is actually rendered and mounted.  the root element does not exist yet. this.$el(option API) ref(composition API)不存在

mounted: after the first render of the component.The element is now available allowing for direct DOM access.

beforeUpdate: Runs when the data is changed, but before the component is re-rendered. This is a good place to update the DOM manually before any changes happen. For example, you can remove event listeners.

updated: once the DOM has been updated.

beforeUnmout: your component is still fully functional and nothing has been destroyed yet.

unmounted: most of your component and its properties are gone so there’s not much you can do.

activated:  whenever a kept-alive dynamic component is “reactivated” – meaning that it is now the active view of the dynamic component.

deactivated: 

debug Hooks:
onRenderTracked
onRenderTriggered: Both of these events take a DebuggerEvent that allows us to tell what is causing a re-render in our Vue instance.

12.  响应式原理
https://vue3js.cn/interview/vue3/proxy.html#%E4%B8%80%E3%80%81object-defineproperty
vue2
```js
function update() {
    app.innerText = obj.foo
}

function defineReactive(obj, key, val) {
    observe(val)
    Object.defineProperty(obj, key, {
        get() {
            return val
        },
        set(newVal) {
            if (newVal !== val) {
                observe(newVal)
                val=  newVal
                update()
            }
        }
    })
}

function observe(obj) {
    if (typeof obj !== 'object' || obj === null) {
        return;
    }
    
    Object.keys(obj).forEach((key) => {
      defineReactive(obj, key, obj[key])  
    })
}
```


vue3
```js
function reactive(obj) {
    if (typeof obj !== 'object' || obj === null) return;

    const observed = new Proxy(obj, {
        get(target, key, receiver) {
            const res = Reflect.get(...arguments)
            return typeof res === 'object' ? observed(res) : res
        },
        set(target, key, value, receiver) {
            const res = Reflect.set(...arguments)
            return res
        },
        deleteProperty(target, key) {
            const res = Reflect.deleteProperty(...arguments)
            return res
        } 
    })

    return observed
}
```