# 问题总结5
对前面所有内容的总结与复习，以及重点整理

1. *继承问题
https://github.com/mqyqingfeng/Blog/issues/16
2. 深入作用域链
https://github.com/mqyqingfeng/Blog/issues/6
3. 闭包
闭包 = 函数 + 函数能够访问的自由变量
https://github.com/mqyqingfeng/Blog/issues/9
4. *正则表达式
https://juejin.cn/post/6844903845227659271#comment
https://regexper.com/#%2F%5E%5Cd%2B%24%2F
5. IIFE
IIFE实现模块化
在js中， function如果是声明就不能执行， 如果是表达式，后面就可以接括号执行，如
i = functino() {}()
IIFE就是通过括号包括，让其成为表达式，同时实现闭包， 其返回值是函数执行结果而非函数声明
推荐这样写
```js
(function(){} ())
```
也可以
```js
(function())()
```
本质上都一样

可以通过它实现一个模块化
```js
var counter = (function() {
    var i = 0
    return {
        get: function() {
            return i
        },
        set: function(val) {
            i = val
        },
        increment: function() {
            return ++i
        }
    }
}())
```
6. **this
https://github.com/mqyqingfeng/Blog/issues/7
本质上就是考虑Reference type
将()左侧作为一个表达式，将表达式赋值给ref，看ref是不是Reference类型
```js
foo.bar => 
foo.bar可以返回一个Reference
var Reference = {
    base: foo,
    name: 'bar'
}
```
如果是Reference，并且IsPropertyReference(ref) 是true， this= GetBas(ref)为foo
所以this指向foo

7. 垃圾回收
https://juejin.cn/post/6844904016325902344
由于JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。
V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小
V8内存结构主要分为新生代和老生代
对于新生代
Scavenge算法将新生代内存一分为二，每一个部分的空间称为semispace，也就是我们在上图中看见的new_space中划分的两个区域，其中处于激活状态的区域我们称为From空间，未激活(inactive new space)的区域我们称为To空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到From空间，当进行垃圾回收时，如果From空间中尚有存活对象，则会被复制到To空间进行保存，非存活的对象会被自动回收。当复制完成后，From空间和To空间完成一次角色互换，To空间会变为新的From空间，原来的From空间则变为To空间。
对象是否经历过一次Scavenge算法或者To空间的内存占比是否已经超过25%，会将对象分配到老生代
对于老生代
使用Mark-Sweep(标记清除)和Mark-Compact(标记整理)

就是从根节点出发，将子节点标记，最后将所有没标记的清除
根节点：全局对象，本地函数的局部变量和参数，当前嵌套调用链上的其他函数的变量和参数
因为清除后，内存会不连续，所以用标记整理将其连续，将对象全部放到内存一端
Incremental Marking(增量标记)：标记一部分，然后将执行权交给js线程，然后下次再继续标记

避免内存泄漏：
    1. 减少全局变量 2. 定时器要停止 3. 减少闭包 4. 清除DOM引用 5. 使用弱引用

8. 变量对象
https://github.com/mqyqingfeng/Blog/issues/5
9. 浮点数
因为浮点数转为二进制，并不会很准确，所以浮点数精度不准确
0.1 + 0.2 === 0.3 false
不深究

10. 运算符优先级
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

11. 事件循环
https://zhuanlan.zhihu.com/p/33058983

12. *迭代器
https://juejin.cn/post/6844904000131694605
https://zh.javascript.info/generators

13. *获取属性相关
Object.getOwnPropertyNames()获取自身属性（除了Symbol， 不可枚举的也可以获得）
for in（除了Symbol，其他可枚举属性包括继承到的，可以用hasOwnProperty过滤）
Object.keys(给定对象的自身可枚举属性组成的数组)
Object.getOwnPropertySymbols()返回一个给定对象自身的所有 Symbol 属性的数组。

14. 冒泡事件
https://www.cnblogs.com/rubylouvre/p/5080464.html
15. *阻止默认事件和冒泡
阻止默认
```js
e.preventDefault()
window.event.returnValue = false //低版本兼容
return false 
```
阻止冒泡
```js
e.stopPropagation()
e.cancelBubble = true//低版本
```
stopImmediatePropagation() 方法阻止监听同一事件的其他事件监听器被调用。
16. *事件委托
e.target.tagName.toUpperCase() === 'LI'

17. 补充dom相关
https://zh.javascript.info/size-and-scroll
# css
1. BFC
https://zhuanlan.zhihu.com/p/25321647
BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。
2. css优先级
https://zhuanlan.zhihu.com/p/41604775

3. *单行省略
```css
div {
      width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
```

多行布局
```css
div {
      width: 20px;
      word-break: break-all;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 3;//设定为制定行数
      -webkit-box-orient: vertical; //水平还是垂直布置其内容
      text-overflow: ellipsis;
    }
```

4. *层叠上下文
https://zhuanlan.zhihu.com/p/268052770
https://www.cnblogs.com/leftJS/p/11063683.html

5. *居中
https://juejin.cn/post/6844903821529841671#heading-7

# 浏览器
1. *浏览器渲染原理
https://juejin.cn/post/6844904083212468238
https://blog.poetries.top/browser-working-principle/guide/part5/lesson22.html#javascript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-dom-%E7%94%9F%E6%88%90%E7%9A%84

2. *浏览器缓存机制
https://juejin.cn/post/6844903593275817998

3. *前端路由模式
https://blog.csdn.net/Charissa2017/article/details/104779412

4. 同站和跨站 同源和跨域
https://cloud.tencent.com/developer/article/1651506

5. SameSite和Cookie
https://github.com/mqyqingfeng/Blog/issues/157

6. 状态码
2xx成功
3xx重定向（304无修改）
4xx请求错误（404未找到，服务器找不到请求的网页）
5xx服务器错误


## html
1. SPA
https://juejin.cn/post/6895882310458343431


## 手撕代码
1. trim
```js
String.prototype.trim2 = function() {
    let start, end
    let raw = this
    for (let i = 0; i < raw.length; i++) {
        if (raw[i] !== ' ') {
            start = i
            break
        }
    }
    
    for (let i = raw.length; i >= 0; i--) {
        if (raw[i] !== ' ') {
            end = i
            break
        }
    }
    
    return raw.slice(start, end + 1)
}

console.log('   hello  world  '.trim2())
console.log('   hello  world  '.trim())
```
2. 大数相加
3. 判断素数
https://blog.csdn.net/sinat_26811377/article/details/96584293
```js
function isPrime(num) {
    let tmp = Math.sqrt(num)
    for (let i = 2; i <= tmp; i++) {
        if (num % i === 0) return false
    }
    return true
}
function isPrime2(num) {
    if (num <= 3) return num > 1
    if (num % 6 !== 5 && num % 6 !== 1) return false
    let tmp = Math.sqrt(num)
    for (let i = 5; i <= tmp; i+=6) {
        if (num % i === 0 || (num % (i + 2) === 0)) return false
    }
    return true
}
```

4. 千位符号制作
```js
function numFormat(num) {
    let arr = num.toString().split('.')
    let s = arr[1]
    let raw = arr[0]
    let res = []

    for (let i = raw.length - 1, count = 0; i >= 0; i--) {
        res.push(raw[i])
        count++
        if (count % 3 === 0 && i > 0) res.push(',')
    }

    return res.reverse().join('').concat('.').concat(s)
}
console.log(numFormat(123456789.123456))
```
5. 数组扁平化
https://segmentfault.com/a/1190000021366004
```js
function flat(arr) {
    let arrResult = []
    arr.forEach(item => {
        if (Array.isArray(item)) {
            arrResult.push(flat(item))
        } else {
            arrResult.push(item)
        }
    })
    return arrResult
}

function flat2(arr) {
    return arr.reduce((pre, cur) => {
        if (Array.isArray(cur)) {
            return pre.concat(flat2(cur))
        } else {
            return pre.concat(cur)
        }
    }, [])
}

function flat3(arr) {
    let resArr = []
    let stack = [].concat(arr)
    while (stack.length) {
        let val = stack.pop()
        if (Array.isArray(val)) {
            stack.push(...val)
        } else {
            resArr.unshift(val)
        }
    }
}

function flat4(arr, num = 1) {
    return num > 0
    ? arr.reduce((pre, cur) => {
        if (Array.isArray(cur)) {
            return pre.concat(flat4(cur, num--))
        } else {
            return pre.concat(cur)
        }
    }, [])
    : arr.slice()
}

function* flat5(arr, num = 1) {
    for (const item of arr) {
        if (Array.isArray(item)) {
            yield* flat(item, num - 1)
        } else {
            yield item
        }
    }
}

Array.prototype.flat6 = function(num = 1) {
    let arr = this.concat()
    return num > 0
        ? arr.reduce((pre, cur) => {
            if (Array.isArray(cur)) {
                return pre.concat(cur.flat6(num--))
            } else {
                return pre.concat(cur)
            }
        }, [])
        : arr.slice()
}


const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }];
console.log(arr.flat6(100))

```

6. 模板引擎
https://github.com/mqyqingfeng/Blog/issues/63

7. 深拷贝
https://cloud.tencent.com/developer/article/1497418
自己简化版
```js
function deepClone(target, map = new WeakMap()) {
    if (!isObject(target)) return target

    if (map.has(target)) return target
    map.add(target)

    const type = getType(target)
    let res = getInit(target)
    if (type === 'map') {
        target.forEach((value, key) => {
            res.set(key, deepClone(value))
        })
    } else if (type === 'set') {
        target.forEach(item => {
            res.add(deepClone(item))
        })
    } else {
        for (let key in target) {
            if (target.hasOwnProperty(key)) {
                if (isObject(target[key])) {
                    res[key] = deepClone(target[key], map)
                } else {
                    res[key] = target[key]
                }
            }
        }
    }
    
    return res
}

function isObject(target) {
    if (target !== null && (typeof target === 'object' || typeof target === 'function')) return true
    return false
}

function getType(target) {
    return Object.prototype.toString.call(target).slice(8, -1).toLowerCase()
}

function getInit(target) {
    let Ctor = target.constructor
    return new Ctor()
}

let set = new Set([1, 2, 3])
let map = new Map([[1, 2], [1, 3]])
let obj = {
    a: 1,
    b: [2, 3],
    c: 4,
    b: {
        d: 5,
        e: 6
    },
    g: map,
    h: set
}
obj.f = obj
console.log(deepClone(obj, new WeakSet()))
```
https://juejin.cn/post/6946022649768181774#heading-20
8. class继承
```js
class Animal {
    constructor(name) {
        this.name = name
    }
    getName() {
        return this.name
    }
}

class Dog extends Animal {
    constructor(name) {
        super(name)
    }
    getName() {
        return super.getName()
    }
}
const d = new Dog('a')
console.log(d.getName())
```

9. 事件总线
```js
class EventEmitter {
    constructor() {
        this.cache = {}
    }
    on(name, fn) {
        if (!this.cache[name]) this.cache[name] = []
        this.cache[name].push(fn)
    }
    off(name, fn) {
        if (!this.cache[name]) return;
        let index = this.cache[name].indexOf(fn)
        if (index >= 0) this.cache[name].splice(index, 1)
    }
    emit(name, once = false, ...args) {
        let tasks = this.cache[name]
        tasks.forEach(task => {
            task(...args)
        })
        if (once) delete this.cache[name] 
    }
}

let eventBus = new EventEmitter()
let fn1 = function(name, age) {
	console.log(`${name} ${age}`)
}
let fn2 = function(name, age) {
	console.log(`hello, ${name} ${age}`)
}
eventBus.on('aaa', fn1)
eventBus.on('aaa', fn2)
eventBus.emit('aaa', false, '布兰', 12)


```

10. url解析
```js
function parseParam(url) {
    const paramStr = url.split('?')[1]
    const paramArr = paramStr.split('&')
    let obj = {}
    for (const m of paramArr) {
        let [key, value] = m.split('=')
        value = decodeURIComponent(value)
        if (!obj[key]) obj[key] = []
        obj[key].push(value)
    }
    return obj
}

console.log(parseParam('https://www.baidu.com/s?wd=%E5%B7%B4%E8%90%A8&rsv_spt=1&rsv_iqid=0xc521bf5a00045397&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_dl=tb&rsv_sug3=5&rsv_sug1=1&rsv_sug7=100&rsv_sug2=0&rsv_btype=i&prefixsug=%25E5%25B7%25B4%25E8%2590%25A8&rsp=4&inputT=1172&rsv_sug4=1172'))
```

11. 模板字符串
```js
function render(template, data) {
    const reg = /\{\{(\w+)\}\}/
    if (reg.test(template)) {
        const name = reg.exec(template)[1]
        template = template.replace(reg, data[name])
        return render(template, data)
    }
    return template
}
let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';
let person = {
    name: '布兰',
    age: 12
}
render(template, person); // 我是布兰，年龄12，性别undefined
console.log(render(template, person))
```

12. 图片懒加载
```js
const imgs = document.querySelectorAll('img')
const viewHeight = window.innerHeight || document.documentElement.clientHeight
let num = 0

function lazyload() {
    for (let i = num; i < imgs.length; i++) {
        let distance = viewHeight - imgs[i].getBoundingClientRect().top
        if (distance >= 0) {
            imgs[i].src = imgs[i].getAttribute('data-src')
            num = i + 1
        }
    }
}

function debouce(fn, delay) {
    let timer 
    return function(...args) {
        if (timer) clearTimeout(timer)
        timer = setTimeout(function() {
            fn.call(this, ...args)
        }, delay)
    }
}

window.onload = lazyload
window.addEventListener('scroll', debouce(lazyload, 600), false)
```

13. curry
```js
function curry(fn) {
    let judge = (...args) => {
        if (args.length === fn.length) return fn(...args)
        return (...arg) => {
            return judge(...args, ...arg)
        }
    }
    return judge
}
```

14. 偏函数
```js
function patiral(fn, ...args) {
    return (...arg) => {
        return fn(...args, ...arg)
    }
}
function add(a, b, c) {
    return a + b + c
}
let patiralAdd = patiral(add, 1)
console.log(patiralAdd(2, 3))
```

15. jsonp
```js
const jsonp = ({url, params, callbackName}) => {
    const generateUrl = () => {
        let dataSrc = ''
        for (let key in params) {
            dataSrc += `${key}=${params[key]}&`
        }
        dataSrc += `callback=${callbackName}`
        return `${url}?${dataSrc}`
    }
    return new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = generateUrl()
        document.body.append(script)
        window[callbackName] = data => {
            resolve(data)
            document.removeChild(script)
            script = null
        }
    })
}
```

16. ajax
```js
const getJSON = function(url) {
    return new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest()
        xhr.open('GET', url)
        xhr.setRequestHeader('Accept', 'application/json')
        xhr.onreadystatechange = function() {
            if (xhr.readyState !== 4) return;
            if (xhr.status === 200 || xhr.status === 304) {
                resolve(xhr.responseText)
            } else {
                reject(xhr.responseText)
            }
        }
        xhr.send()
    })
}
```

17. 数组相关
```js
Array.prototype.forEach2 = function(callback, thisArg) {
    if (this === null) throw new TypeError()
    if (typeof callback !== 'function') throw new TypeError()
    const arr = Object(this)
    const len = arr.length >>> 0
    let k = 0
    while (k < len) {
        if (k in arr) callback.call(thisArg, arr[k], k, arr)
        k++
    }
}

Array.prototype.filter2 = function(callback, thisArg) {
    if (this === null) throw new TypeError()
    if (typeof callback !== 'function') throw new TypeError()
    let res = []
    let arr = Object(this)
    let len = arr.length >>> 0
    for (let i =0; i < len; i++) {
        if (i in arr) {
            if (callback.call(thisArg, arr[i], i, arr)) {
                res.push(arr[i])
            }
        }
    }
    return res
}

Array.prototype.reduce2 = function(callback, init) {
    if (this === null) throw new TypeError()
    if (typeof callback !== 'function') throw new TypeError()
    let arr = Object(this)
    if (init  === undefined && arr.length >= 1) init = arr.shift()
    let len = arr.length >>> 0
    for (let i = 0; i < len; i++) {
        init = callback(init, arr[i], i, arr)
    }
    return init
}
```

18. call apply bind
```js
Function.prototype.call2 = function(thisArg, ...args) {
    var context = thisArg || window
    thisArg.fn = this
    let res = thisArg.fn(...args)
    delete thisArg.fn
    return res
}

Function.prototype.bind2 = function(thisArg, ...args) {
    var context = thisArg || window
    let fn = this
    let Pro = function() {}
    Pro.prototype = this.prototype
    let Bound =  function() {
        if (this instanceof Pro) {
            return fn.apply(this, args.concat(arguments))
        } else {
            return fn.apply(context, args.concat(arguments))
        }
    }
    Bound.prototype = new Bound()
    return Bound
}
```

19. new
```js
function newObject() {
    const Con = [].shift.call(arguments)
    let obj = new Object()
    Object.setPrototypeOf(obj, Con.prototype)
    let res = Con.apply(obj, arguments)
    return typeof res === 'object' ? res : obj
}
```
20. instanceof
21. 中间跳过几个，下一轮复习再写
22. Promise.resolve
```js
Promise.resolve2 = function(p) {
    if (p instanceof Promise) return p
    return new Promise((resolve, reject) => {
        resolve(p)
    })
}
```
23. Promise.all
```js
Promise.all2 = function(arrs) {
    let res = [],
        index = 0
    return new Promise((resolve, reject) => {
        arrs.forEach((item, i) => {
            Promise.resolve(item).then(value => {
                res[i] = value
                index++
                if (index === arrs.length) resolve(res)
            }, reason => {
                reject(reason)
            })
        })
    })
}
```
23. 后面还有几个，下次再做