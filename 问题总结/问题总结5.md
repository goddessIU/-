# 问题总结5
对前面所有内容的总结与复习，以及重点整理

1. *继承问题
https://github.com/mqyqingfeng/Blog/issues/16
2. 深入作用域链
https://github.com/mqyqingfeng/Blog/issues/6
3. 闭包
闭包 = 函数 + 函数能够访问的自由变量
https://github.com/mqyqingfeng/Blog/issues/9
4. *正则表达式
https://juejin.cn/post/6844903845227659271#comment
https://regexper.com/#%2F%5E%5Cd%2B%24%2F
5. IIFE
IIFE实现模块化
在js中， function如果是声明就不能执行， 如果是表达式，后面就可以接括号执行，如
i = functino() {}()
IIFE就是通过括号包括，让其成为表达式，同时实现闭包， 其返回值是函数执行结果而非函数声明
推荐这样写
```js
(function(){} ())
```
也可以
```js
(function())()
```
本质上都一样

可以通过它实现一个模块化
```js
var counter = (function() {
    var i = 0
    return {
        get: function() {
            return i
        },
        set: function(val) {
            i = val
        },
        increment: function() {
            return ++i
        }
    }
}())
```
6. **this
https://github.com/mqyqingfeng/Blog/issues/7
本质上就是考虑Reference type
将()左侧作为一个表达式，将表达式赋值给ref，看ref是不是Reference类型
```js
foo.bar => 
foo.bar可以返回一个Reference
var Reference = {
    base: foo,
    name: 'bar'
}
```
如果是Reference，并且IsPropertyReference(ref) 是true， this= GetBas(ref)为foo
所以this指向foo

7. 垃圾回收
https://juejin.cn/post/6844904016325902344
由于JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。
V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小
V8内存结构主要分为新生代和老生代
对于新生代
Scavenge算法将新生代内存一分为二，每一个部分的空间称为semispace，也就是我们在上图中看见的new_space中划分的两个区域，其中处于激活状态的区域我们称为From空间，未激活(inactive new space)的区域我们称为To空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到From空间，当进行垃圾回收时，如果From空间中尚有存活对象，则会被复制到To空间进行保存，非存活的对象会被自动回收。当复制完成后，From空间和To空间完成一次角色互换，To空间会变为新的From空间，原来的From空间则变为To空间。
对象是否经历过一次Scavenge算法或者To空间的内存占比是否已经超过25%，会将对象分配到老生代
对于老生代
使用Mark-Sweep(标记清除)和Mark-Compact(标记整理)

就是从根节点出发，将子节点标记，最后将所有没标记的清除
根节点：全局对象，本地函数的局部变量和参数，当前嵌套调用链上的其他函数的变量和参数
因为清除后，内存会不连续，所以用标记整理将其连续，将对象全部放到内存一端
Incremental Marking(增量标记)：标记一部分，然后将执行权交给js线程，然后下次再继续标记

避免内存泄漏：
    1. 减少全局变量 2. 定时器要停止 3. 减少闭包 4. 清除DOM引用 5. 使用弱引用

8. 变量对象
https://github.com/mqyqingfeng/Blog/issues/5
9. 浮点数
因为浮点数转为二进制，并不会很准确，所以浮点数精度不准确
0.1 + 0.2 === 0.3 false
不深究

10. 运算符优先级
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

11. 事件循环
https://zhuanlan.zhihu.com/p/33058983

12. *迭代器
https://juejin.cn/post/6844904000131694605
https://zh.javascript.info/generators

# css
1. BFC
https://zhuanlan.zhihu.com/p/25321647
BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。
2. css优先级
https://zhuanlan.zhihu.com/p/41604775

3. *单行省略
```css
div {
      width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
```

多行布局
```css
div {
      width: 20px;
      word-break: break-all;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 3;//设定为制定行数
      -webkit-box-orient: vertical; //水平还是垂直布置其内容
      text-overflow: ellipsis;
    }
```

4. *层叠上下文
https://zhuanlan.zhihu.com/p/268052770
https://www.cnblogs.com/leftJS/p/11063683.html

5. *居中
https://juejin.cn/post/6844903821529841671#heading-7

# 浏览器
1. *浏览器渲染原理
https://juejin.cn/post/6844904083212468238
https://blog.poetries.top/browser-working-principle/guide/part5/lesson22.html#javascript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-dom-%E7%94%9F%E6%88%90%E7%9A%84

2. *浏览器缓存机制
https://juejin.cn/post/6844903593275817998

3. *前端路由模式
https://blog.csdn.net/Charissa2017/article/details/104779412

4. 同站和跨站 同源和跨域
https://cloud.tencent.com/developer/article/1651506

5. SameSite和Cookie
https://github.com/mqyqingfeng/Blog/issues/157




## html
1. SPA
https://juejin.cn/post/6895882310458343431